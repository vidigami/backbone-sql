// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.10
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, KNEX_COLUMN_OPTIONS, KNEX_SKIP, KNEX_TYPES, Knex, Queue, knexColumnBuilder, knex_helpers, _, _deprecate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  Knex = require('knex');

  Queue = require('backbone-orm/lib/queue');

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  knex_helpers = require('knex/lib/helpers');

  KNEX_SKIP = ['The five argument join'];

  _deprecate = knex_helpers.deprecate;

  knex_helpers.deprecate = function(msg) {
    if (msg.indexOf(KNEX_SKIP) !== 0) {
      return _deprecate.apply(this, _.toArray(arguments));
    }
  };

  KNEX_TYPES = {
    datetime: 'dateTime',
    biginteger: 'bigInteger'
  };

  knexColumnBuilder = function(table, key) {
    var _ref;
    if (table.columns) {
      return _.find(table.columns, function(col) {
        return col.name === key;
      });
    } else {
      return (_ref = _.find(table._statements, function(col) {
        var _ref1;
        return col.grouping === 'columns' && ((_ref1 = col.builder._args) != null ? _ref1[0] : void 0) === key;
      })) != null ? _ref.builder : void 0;
    }
  };

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = __bind(this.renameTable, this);
      this.dropTableIfExists = __bind(this.dropTableIfExists, this);
      this.dropTable = __bind(this.dropTable, this);
      this.hasTable = __bind(this.hasTable, this);
      this.hasColumn = __bind(this.hasColumn, this);
      this.updateColumn = __bind(this.updateColumn, this);
      this.addColumn = __bind(this.addColumn, this);
      this.createOrUpdateTable = __bind(this.createOrUpdateTable, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.resetSchema = __bind(this.resetSchema, this);
    }

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var queue, _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      if (this.resetting) {
        return callback();
      }
      this.resetting = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.connection.knex().schema.dropTableIfExists(_this.table_name).exec(callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref1;
          join_queue = new Queue(1);
          _ref1 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().resetSchema(callback);
            });
          };
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            join_table = _ref1[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.resetting = false;
          if (err) {
            return callback(err);
          }
          return _this.ensureSchema(options, callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var queue, _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.createOrUpdateTable(options, callback);
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          var join_queue, join_table, _fn, _i, _len, _ref1;
          join_queue = new Queue(1);
          _ref1 = _this.schema.joinTables();
          _fn = function(join_table) {
            return join_queue.defer(function(callback) {
              return join_table.db().ensureSchema(callback);
            });
          };
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            join_table = _ref1[_i];
            _fn(join_table);
          }
          return join_queue.await(callback);
        };
      })(this));
      return queue.await((function(_this) {
        return function(err) {
          _this.ensuring = false;
          return callback(err);
        };
      })(this));
    };

    DatabaseTools.prototype.createOrUpdateTable = function(options, callback) {
      this.hasTable((function(_this) {
        return function(err, table_exists) {
          var columns, key, queue, _fn, _i, _len, _ref;
          if (err) {
            return callback(err);
          }
          if (options.verbose) {
            console.log("Ensuring table: " + _this.table_name + " (exists: " + (!!table_exists) + ") with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
          }
          columns = {
            add: [],
            update: []
          };
          queue = new Queue();
          _ref = _this.schema.columns();
          _fn = function(key) {
            return queue.defer(function(callback) {
              var column, field, override;
              if (field = _this.schema.fields[key]) {
                column = {
                  key: key,
                  type: field.type.toLowerCase(),
                  options: field
                };
                if (override = KNEX_TYPES[column.type]) {
                  column.type = override;
                }
              } else if (key === 'id') {
                column = {
                  key: key,
                  type: 'increments',
                  options: {
                    indexed: true,
                    primary: true
                  }
                };
              } else {
                column = {
                  key: key,
                  type: 'integer',
                  options: {
                    indexed: true,
                    nullable: true
                  }
                };
              }
              if (!table_exists) {
                columns.add.push(column);
                return callback();
              }
              return _this.hasColumn(key, function(err, exists) {
                if (err) {
                  return callback(err);
                }
                columns[exists ? 'update' : 'add'].push(column);
                return callback();
              });
            });
          };
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            _fn(key);
          }
          return _this.connection.knex().schema[table_exists ? 'table' : 'createTable'](_this.table_name, function(table) {
            var column, _j, _k, _len1, _len2, _ref1, _ref2, _results;
            _ref1 = columns.add;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              column = _ref1[_j];
              _this.addColumn(table, column);
            }
            _ref2 = columns.update;
            _results = [];
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              column = _ref2[_k];
              _results.push(_this.updateColumn(table, column));
            }
            return _results;
          }).exec(callback);
        };
      })(this));
    };

    DatabaseTools.prototype.addColumn = function(table, column_info) {
      var column_args, constructor_options, _ref;
      column_args = [column_info.key];
      constructor_options = _.pick(column_info.options, KNEX_COLUMN_OPTIONS);
      if (!_.isEmpty(constructor_options)) {
        if ((_ref = column_info.type) === 'float' || _ref === 'decimal') {
          column_args[1] = constructor_options['precision'];
          column_args[2] = constructor_options['scale'];
        } else {
          column_args[1] = _.values(constructor_options)[0];
        }
      }
      table[column_info.type].apply(table, column_args);
      this.updateColumn(table, column_info);
    };

    DatabaseTools.prototype.updateColumn = function(table, column_info) {
      var column;
      column = knexColumnBuilder(table, column_info.key);
      if (column_info.options.primary) {
        column.primary();
      }
      if (!!column_info.options.nullable) {
        column.nullable();
      }
      if (column_info.options.indexed) {
        column.index();
      }
      if (column_info.options.unique) {
        column.unique();
      }
    };

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
